#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  defineConfig: () => defineConfig
});
module.exports = __toCommonJS(src_exports);
var import_cac = __toESM(require("cac"), 1);

// package.json
var version = "1.0.19";

// src/command/git-commit.ts
var import_node_path = __toESM(require("path"), 1);
var import_node_fs = require("fs");
var import_enquirer = require("enquirer");
var import_kolorist = require("kolorist");

// src/shared/index.ts
async function execCommand(cmd, args, options) {
  const { execa } = await import("execa");
  const res = await execa(cmd, args, options);
  return res?.stdout?.trim() || "";
}

// src/command/git-commit.ts
async function gitCommit(gitCommitTypes, gitCommitScopes) {
  const typesChoices = gitCommitTypes.map(([value, msg]) => {
    const nameWithSuffix = `${value}:`;
    const message = `${nameWithSuffix.padEnd(12)}${msg}`;
    return {
      name: value,
      message
    };
  });
  const scopesChoices = gitCommitScopes.map(([value, msg]) => ({
    name: value,
    message: `${value.padEnd(30)} (${msg})`
  }));
  const result = await (0, import_enquirer.prompt)([
    {
      name: "types",
      type: "select",
      message: "Please select a type",
      choices: typesChoices
    },
    {
      name: "scopes",
      type: "select",
      message: "Please select a scope",
      choices: scopesChoices
    },
    {
      name: "description",
      type: "text",
      message: `Please enter a description (add prefix ${(0, import_kolorist.yellow)("!")} to indicate breaking change)`
    }
  ]);
  const breaking = result.description.startsWith("!") ? "!" : "";
  const description = result.description.replace(/^!/, "").trim();
  const commitMsg = `${result.types}(${result.scopes})${breaking}: ${description}`;
  await execCommand("git", ["commit", "-m", commitMsg], { stdio: "inherit" });
}
async function gitCommitVerify() {
  const gitPath = await execCommand("git", ["rev-parse", "--show-toplevel"]);
  const gitMsgPath = import_node_path.default.join(gitPath, ".git", "COMMIT_EDITMSG");
  const commitMsg = (0, import_node_fs.readFileSync)(gitMsgPath, "utf8").trim();
  const REG_EXP = /(?<type>[a-z]+)(?:\((?<scope>.+)\))?(?<breaking>!)?: (?<description>.+)/i;
  if (!REG_EXP.test(commitMsg)) {
    throw new Error(
      `${(0, import_kolorist.bgRed)(" ERROR ")} ${(0, import_kolorist.red)("git commit message must match the Conventional Commits standard!")}

${(0, import_kolorist.green)(
        "Recommended to use the command `pnpm commit` to generate Conventional Commits compliant commit information.\nGet more info about Conventional Commits, follow this link: https://conventionalcommits.org"
      )}`
    );
  }
}

// src/command/cleanup.ts
var import_rimraf = require("rimraf");
async function cleanup(paths) {
  await (0, import_rimraf.rimraf)(paths, { glob: true });
}

// src/command/ncu.ts
async function ncu(args = ["--deep", "-u"]) {
  execCommand("npx", ["ncu", ...args], { stdio: "inherit" });
}

// src/command/changelog.ts
var import_changelog = require("@soybeanjs/changelog");
async function genChangelog(options, total = false) {
  if (total) {
    await (0, import_changelog.generateTotalChangelog)(options);
  } else {
    await (0, import_changelog.generateChangelog)(options);
  }
}

// src/command/release.ts
var import_bumpp = require("bumpp");
async function release(execute = "npx soy changelog", push = true) {
  await (0, import_bumpp.versionBump)({
    files: ["**/package.json", "!**/node_modules"],
    execute,
    all: true,
    tag: true,
    commit: "chore(projects): release v%s",
    push
  });
}

// src/config/index.ts
var import_node_process = __toESM(require("process"), 1);
var import_c12 = require("c12");
var defaultOptions = {
  cwd: import_node_process.default.cwd(),
  cleanupDirs: [
    "**/dist",
    "**/package-lock.json",
    "**/yarn.lock",
    "**/pnpm-lock.yaml",
    "**/node_modules",
    "!node_modules/**"
  ],
  gitCommitTypes: [
    ["feat", "A new feature"],
    ["fix", "A bug fix"],
    ["docs", "Documentation only changes"],
    ["style", "Changes that do not affect the meaning of the code"],
    ["refactor", "A code change that neither fixes a bug nor adds a feature"],
    ["perf", "A code change that improves performance"],
    ["optimize", "A code change that optimizes code quality"],
    ["test", "Adding missing tests or correcting existing tests"],
    ["build", "Changes that affect the build system or external dependencies"],
    ["ci", "Changes to our CI configuration files and scripts"],
    ["chore", "Other changes that don't modify src or test files"],
    ["revert", "Reverts a previous commit"]
  ],
  gitCommitScopes: [
    ["projects", "project"],
    ["packages", "packages"],
    ["components", "components"],
    ["hooks", "hook functions"],
    ["utils", "utils functions"],
    ["types", "TS declaration"],
    ["styles", "style"],
    ["deps", "project dependencies"],
    ["release", "release project"],
    ["other", "other changes"]
  ],
  ncuCommandArgs: ["--deep", "-u"],
  changelogOptions: {}
};
async function loadCliOptions(overrides, cwd = import_node_process.default.cwd()) {
  const { config } = await (0, import_c12.loadConfig)({
    name: "soybean",
    defaults: defaultOptions,
    overrides,
    cwd,
    packageJson: true
  });
  return config;
}

// src/index.ts
async function setupCli() {
  const cliOptions = await loadCliOptions();
  const cli = (0, import_cac.default)("soybean");
  cli.version(version).option(
    "-e, --execute [command]",
    "Execute additional command after bumping and before git commit. Defaults to 'npx soy changelog'"
  ).option("-p, --push", "Indicates whether to push the git commit and tag").option("-t, --total", "Generate changelog by total tags").option(
    "-c, --cleanupDir <dir>",
    'The glob pattern of dirs to cleanup, If not set, it will use the default value, Multiple values use "," to separate them'
  ).help();
  const commands = {
    cleanup: {
      desc: "delete dirs: node_modules, dist, etc.",
      action: async (args) => {
        const cleanupDirs = args?.cleanupDir?.split(",") || [];
        const formattedDirs = cleanupDirs.map((dir) => dir.trim()).filter(Boolean);
        if (formattedDirs.length) {
          cliOptions.cleanupDirs = formattedDirs;
        }
        await cleanup(cliOptions.cleanupDirs);
      }
    },
    ncu: {
      desc: "npm-check-updates, it can update package.json dependencies to the latest version",
      action: async () => {
        await ncu(cliOptions.ncuCommandArgs);
      }
    },
    "update-pkg": {
      desc: 'equal to command "ncu"',
      action: async () => {
        await ncu();
      }
    },
    "git-commit": {
      desc: "git commit, generate commit message which match Conventional Commits standard",
      action: async () => {
        await gitCommit(cliOptions.gitCommitTypes, cliOptions.gitCommitScopes);
      }
    },
    "git-commit-verify": {
      desc: "verify git commit message, make sure it match Conventional Commits standard",
      action: async () => {
        await gitCommitVerify();
      }
    },
    changelog: {
      desc: "generate changelog",
      action: async (args) => {
        await genChangelog(cliOptions.changelogOptions, args?.total);
      }
    },
    release: {
      desc: "release: update version, generate changelog, commit code",
      action: async (args) => {
        await release(args?.execute, args?.push);
      }
    }
  };
  for await (const [command, { desc, action }] of Object.entries(commands)) {
    cli.command(command, desc).action(action);
  }
  cli.parse();
}
setupCli();
function defineConfig(config) {
  return config;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  defineConfig
});
