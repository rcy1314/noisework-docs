import {
  consola
} from "./chunk-DZRUSQMM.js";

// src/index.ts
import { Presets, SingleBar } from "cli-progress";

// src/options.ts
import process from "process";
import { readFile } from "fs/promises";

// src/git.ts
import { ofetch } from "ofetch";
import dayjs from "dayjs";
import semver from "semver";

// src/shared.ts
async function execCommand(cmd, args, options) {
  var _a;
  const { execa } = await import("execa");
  const res = await execa(cmd, args, options);
  return ((_a = res == null ? void 0 : res.stdout) == null ? void 0 : _a.trim()) || "";
}
function notNullish(v) {
  return v !== null && v !== void 0;
}
function partition(array, ...filters) {
  const result = Array.from({ length: filters.length + 1 }).fill(null).map(() => []);
  array.forEach((e, idx, arr) => {
    let i = 0;
    for (const filter of filters) {
      if (filter(e, idx, arr)) {
        result[i].push(e);
        return;
      }
      i += 1;
    }
    result[i].push(e);
  });
  return result;
}
function groupBy(items, key, groups = {}) {
  for (const item of items) {
    const v = item[key];
    groups[v] || (groups[v] = []);
    groups[v].push(item);
  }
  return groups;
}
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function join(array, glue = ", ", finalGlue = " and ") {
  if (!array || array.length === 0)
    return "";
  if (array.length === 1)
    return array[0];
  if (array.length === 2)
    return array.join(finalGlue);
  return `${array.slice(0, -1).join(glue)}${finalGlue}${array.slice(-1)}`;
}

// src/constant.ts
var VERSION_REG = /^v\d+\.\d+\.\d+(-(beta|alpha)\.\d+)?/;
var VERSION_REG_OF_MARKDOWN = /## \[v\d+\.\d+\.\d+(-(beta|alpha)\.\d+)?]/g;
var VERSION_WITH_RELEASE = /release\sv\d+\.\d+\.\d+(-(beta|alpha)\.\d+)?/;

// src/git.ts
async function getTotalGitTags() {
  const tagStr = await execCommand("git", ["--no-pager", "tag", "-l", "--sort=v:refname"]);
  const tags = tagStr.split("\n");
  const filtered = tags.filter((tag) => VERSION_REG.test(tag));
  return semver.sort(filtered);
}
async function getTagDateMap() {
  const tagDateStr = await execCommand("git", [
    "--no-pager",
    "log",
    "--tags",
    "--simplify-by-decoration",
    "--pretty=format:%ci %d"
  ]);
  const TAG_MARK = "tag: ";
  const map = /* @__PURE__ */ new Map();
  const dates = tagDateStr.split("\n").filter((item) => item.includes(TAG_MARK));
  dates.forEach((item) => {
    var _a;
    const [dateStr, tagStr] = item.split(TAG_MARK);
    const date = dayjs(dateStr).format("YYYY-MM-DD");
    const tag = (_a = tagStr.match(VERSION_REG)) == null ? void 0 : _a[0];
    if (tag && date) {
      map.set(tag.trim(), date);
    }
  });
  return map;
}
function getFromToTags(tags) {
  const result = [];
  if (tags.length < 2) {
    return result;
  }
  const releaseTags = tags.filter((tag) => !isPrerelease(tag));
  const reversedTags = [...tags].reverse();
  reversedTags.forEach((tag, index) => {
    if (index < reversedTags.length - 1) {
      const to = tag;
      let from = reversedTags[index + 1];
      if (!isPrerelease(to)) {
        const toIndex = releaseTags.indexOf(to);
        from = releaseTags[toIndex - 1];
      }
      result.push({ from, to });
    }
  });
  return result.reverse();
}
async function getGitMainBranchName() {
  const main = await execCommand("git", ["rev-parse", "--abbrev-ref", "HEAD"]);
  return main;
}
async function getCurrentGitBranch() {
  const tag = await execCommand("git", ["tag", "--points-at", "HEAD"]);
  const main = getGitMainBranchName();
  return tag || main;
}
async function getGitHubRepo() {
  const url = await execCommand("git", ["config", "--get", "remote.origin.url"]);
  const match = url.match(/github\.com[/:]([\w\d._-]+?)\/([\w\d._-]+?)(\.git)?$/i);
  if (!match) {
    throw new Error(`Can not parse GitHub repo from url ${url}`);
  }
  return `${match[1]}/${match[2]}`;
}
function isPrerelease(version) {
  const REG = /^[^.]*[\d.]+$/;
  return !REG.test(version);
}
function getFirstGitCommit() {
  return execCommand("git", ["rev-list", "--max-parents=0", "HEAD"]);
}
async function getGitDiff(from, to = "HEAD") {
  const rawGit = await execCommand("git", [
    "--no-pager",
    "log",
    `${from ? `${from}...` : ""}${to}`,
    '--pretty="----%n%s|%h|%an|%ae%n%b"',
    "--name-status"
  ]);
  const rwaGitLines = rawGit.split("----\n").splice(1);
  const gitCommits = rwaGitLines.map((line) => {
    const [firstLine, ...body] = line.split("\n");
    const [message, shortHash, authorName, authorEmail] = firstLine.split("|");
    const gitCommit = {
      message,
      shortHash,
      author: { name: authorName, email: authorEmail },
      body: body.join("\n")
    };
    return gitCommit;
  });
  return gitCommits;
}
function parseGitCommit(commit) {
  const ConventionalCommitRegex = /(?<type>[a-z]+)(\((?<scope>.+)\))?(?<breaking>!)?: (?<description>.+)/i;
  const CoAuthoredByRegex = /co-authored-by:\s*(?<name>.+)(<(?<email>.+)>)/gim;
  const PullRequestRE = /\([a-z]*(#\d+)\s*\)/gm;
  const IssueRE = /(#\d+)/gm;
  const match = commit.message.match(ConventionalCommitRegex);
  if (!(match == null ? void 0 : match.groups)) {
    return null;
  }
  const type = match.groups.type;
  const scope = match.groups.scope || "";
  const isBreaking = Boolean(match.groups.breaking);
  let description = match.groups.description;
  const references = [];
  for (const m of description.matchAll(PullRequestRE)) {
    references.push({ type: "pull-request", value: m[1] });
  }
  for (const m of description.matchAll(IssueRE)) {
    if (!references.some((i) => i.value === m[1])) {
      references.push({ type: "issue", value: m[1] });
    }
  }
  references.push({ value: commit.shortHash, type: "hash" });
  description = description.replace(PullRequestRE, "").trim();
  const authors = [commit.author];
  const matches = commit.body.matchAll(CoAuthoredByRegex);
  for (const $match of matches) {
    const { name = "", email = "" } = $match.groups || {};
    const author = {
      name: name.trim(),
      email: email.trim()
    };
    authors.push(author);
  }
  return {
    ...commit,
    authors,
    resolvedAuthors: [],
    description,
    type,
    scope,
    references,
    isBreaking
  };
}
async function getGitCommits(from, to = "HEAD") {
  const rwaGitCommits = await getGitDiff(from, to);
  const commits = rwaGitCommits.map((commit) => parseGitCommit(commit)).filter(notNullish);
  return commits;
}
function getHeaders(githubToken) {
  return {
    accept: "application/vnd.github.v3+json",
    authorization: `token ${githubToken}`
  };
}
async function getResolvedAuthorLogin(github, commitHashes, email) {
  var _a, _b;
  let login = "";
  try {
    const data = await ofetch(`https://ungh.cc/users/find/${email}`);
    login = ((_a = data == null ? void 0 : data.user) == null ? void 0 : _a.username) || "";
  } catch (e) {
    consola.log("e: ", e);
  }
  if (login) {
    return login;
  }
  const { repo, token } = github;
  if (!token) {
    return login;
  }
  if (commitHashes.length) {
    try {
      const data = await ofetch(`https://api.github.com/repos/${repo}/commits/${commitHashes[0]}`, {
        headers: getHeaders(token)
      });
      login = ((_b = data == null ? void 0 : data.author) == null ? void 0 : _b.login) || "";
    } catch (e) {
      consola.log("e: ", e);
    }
  }
  if (login) {
    return login;
  }
  try {
    const data = await ofetch(`https://api.github.com/search/users?q=${encodeURIComponent(email)}`, {
      headers: getHeaders(token)
    });
    login = data.items[0].login;
  } catch (e) {
    consola.log("e: ", e);
  }
  return login;
}
async function getGitCommitsAndResolvedAuthors(commits, github, resolvedLogins) {
  const resultCommits = [];
  const map = /* @__PURE__ */ new Map();
  for await (const commit of commits) {
    const resolvedAuthors = [];
    for await (const [index, author] of commit.authors.entries()) {
      const { email, name } = author;
      if (email && name) {
        const commitHashes = [];
        if (index === 0) {
          commitHashes.push(commit.shortHash);
        }
        const resolvedAuthor = {
          name,
          email,
          commits: commitHashes,
          login: ""
        };
        if (!(resolvedLogins == null ? void 0 : resolvedLogins.has(email))) {
          const login = await getResolvedAuthorLogin(github, commitHashes, email);
          resolvedAuthor.login = login;
          resolvedLogins == null ? void 0 : resolvedLogins.set(email, login);
        } else {
          const login = (resolvedLogins == null ? void 0 : resolvedLogins.get(email)) || "";
          resolvedAuthor.login = login;
        }
        resolvedAuthors.push(resolvedAuthor);
        if (!map.has(email)) {
          map.set(email, resolvedAuthor);
        }
      }
    }
    const resultCommit = { ...commit, resolvedAuthors };
    resultCommits.push(resultCommit);
  }
  return {
    commits: resultCommits,
    contributors: Array.from(map.values())
  };
}

// src/options.ts
function createDefaultOptions() {
  const cwd = process.cwd();
  const options = {
    cwd,
    types: {
      feat: "\u{1F680} Features",
      fix: "\u{1F41E} Bug Fixes",
      perf: "\u{1F525} Performance",
      optimize: "\u{1F6E0} Optimizations",
      refactor: "\u{1F485} Refactors",
      docs: "\u{1F4D6} Documentation",
      build: "\u{1F4E6} Build",
      types: "\u{1F30A} Types",
      chore: "\u{1F3E1} Chore",
      examples: "\u{1F3C0} Examples",
      test: "\u2705 Tests",
      style: "\u{1F3A8} Styles",
      ci: "\u{1F916} CI"
    },
    github: {
      repo: "",
      token: process.env.GITHUB_TOKEN || ""
    },
    from: "",
    to: "",
    tags: [],
    tagDateMap: /* @__PURE__ */ new Map(),
    capitalize: false,
    emoji: true,
    titles: {
      breakingChanges: "\u{1F6A8} Breaking Changes"
    },
    output: "CHANGELOG.md",
    regenerate: false
  };
  return options;
}
async function getVersionFromPkgJson(cwd) {
  let newVersion = "";
  try {
    const pkgJson = await readFile(`${cwd}/package.json`, "utf-8");
    const pkg = JSON.parse(pkgJson);
    newVersion = (pkg == null ? void 0 : pkg.version) || "";
  } catch {
  }
  return {
    newVersion
  };
}
async function createOptions(options) {
  var _a;
  const opts = createDefaultOptions();
  Object.assign(opts, options);
  const { newVersion } = await getVersionFromPkgJson(opts.cwd);
  (_a = opts.github).repo || (_a.repo = await getGitHubRepo());
  const tags = await getTotalGitTags();
  opts.tags = tags;
  opts.from || (opts.from = tags[tags.length - 1]);
  opts.to || (opts.to = `v${newVersion}`);
  if (opts.to === opts.from) {
    const lastTag = tags[tags.length - 2];
    const firstCommit = await getFirstGitCommit();
    opts.from = lastTag || firstCommit;
  }
  opts.tagDateMap = await getTagDateMap();
  opts.prerelease || (opts.prerelease = isPrerelease(opts.to));
  const isFromPrerelease = isPrerelease(opts.from);
  if (!isPrerelease(newVersion) && isFromPrerelease) {
    const allReleaseTags = opts.tags.filter((tag) => !isPrerelease(tag) && tag !== opts.to);
    opts.from = allReleaseTags[allReleaseTags.length - 1];
  }
  return opts;
}

// src/markdown.ts
import { existsSync } from "fs";
import { readFile as readFile2, writeFile } from "fs/promises";
import dayjs2 from "dayjs";
import { convert } from "convert-gitmoji";
function formatReferences(references, githubRepo, type) {
  const refs = references.filter((i) => {
    if (type === "issues")
      return i.type === "issue" || i.type === "pull-request";
    return i.type === "hash";
  }).map((ref) => {
    if (!githubRepo)
      return ref.value;
    if (ref.type === "pull-request" || ref.type === "issue")
      return `https://github.com/${githubRepo}/issues/${ref.value.slice(1)}`;
    return `[<samp>(${ref.value.slice(0, 5)})</samp>](https://github.com/${githubRepo}/commit/${ref.value})`;
  });
  const referencesString = join(refs).trim();
  if (type === "issues")
    return referencesString && `in ${referencesString}`;
  return referencesString;
}
function formatLine(commit, options) {
  const prRefs = formatReferences(commit.references, options.github.repo, "issues");
  const hashRefs = formatReferences(commit.references, options.github.repo, "hash");
  let authors = join([...new Set(commit.resolvedAuthors.map((i) => i.login ? `@${i.login}` : `**${i.name}**`))]).trim();
  if (authors) {
    authors = `by ${authors}`;
  }
  let refs = [authors, prRefs, hashRefs].filter((i) => i == null ? void 0 : i.trim()).join(" ");
  if (refs) {
    refs = `&nbsp;-&nbsp; ${refs}`;
  }
  const description = options.capitalize ? capitalize(commit.description) : commit.description;
  return [description, refs].filter((i) => i == null ? void 0 : i.trim()).join(" ");
}
function formatTitle(name, options) {
  const emojisRE = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;
  let formatName = name.trim();
  if (!options.emoji) {
    formatName = name.replace(emojisRE, "").trim();
  }
  return `### &nbsp;&nbsp;&nbsp;${formatName}`;
}
function formatSection(commits, sectionName, options) {
  if (!commits.length)
    return [];
  const lines = ["", formatTitle(sectionName, options), ""];
  const scopes = groupBy(commits, "scope");
  let useScopeGroup = true;
  if (!Object.entries(scopes).some(([k, v]) => k && v.length > 1)) {
    useScopeGroup = false;
  }
  Object.keys(scopes).sort().forEach((scope) => {
    let padding = "";
    let prefix = "";
    const scopeText = `**${scope}**`;
    if (scope && useScopeGroup) {
      lines.push(`- ${scopeText}:`);
      padding = "  ";
    } else if (scope) {
      prefix = `${scopeText}: `;
    }
    lines.push(...scopes[scope].reverse().map((commit) => `${padding}- ${prefix}${formatLine(commit, options)}`));
  });
  return lines;
}
function getUserGithub(userName) {
  const githubUrl = `https://github.com/${userName}`;
  return githubUrl;
}
function getGitUserAvatar(userName) {
  const githubUrl = getUserGithub(userName);
  const avatarUrl = `${githubUrl}.png?size=48`;
  return avatarUrl;
}
function createContributorLine(contributors) {
  let loginLine = "";
  let unLoginLine = "";
  const contributorMap = /* @__PURE__ */ new Map();
  contributors.forEach((contributor) => {
    contributorMap.set(contributor.email, contributor);
  });
  const filteredContributors = Array.from(contributorMap.values());
  filteredContributors.forEach((contributor, index) => {
    const { name, email, login } = contributor;
    if (!login) {
      let line = `[${name}](mailto:${email})`;
      if (index < contributors.length - 1) {
        line += ",&nbsp;";
      }
      unLoginLine += line;
    } else {
      const githubUrl = getUserGithub(login);
      const avatar = getGitUserAvatar(login);
      loginLine += `[![${login}](${avatar})](${githubUrl})&nbsp;&nbsp;`;
    }
  });
  return `${loginLine}
${unLoginLine}`;
}
function generateMarkdown(params) {
  const { options, showTitle, contributors } = params;
  const commits = params.commits.filter((commit) => commit.description.match(VERSION_WITH_RELEASE) === null);
  const lines = [];
  const url = `https://github.com/${options.github.repo}/compare/${options.from}...${options.to}`;
  if (showTitle) {
    const date = options.tagDateMap.get(options.to) || dayjs2().format("YYYY-MM-DD");
    let title = `## [${options.to}](${url})`;
    if (date) {
      title += ` (${date})`;
    }
    lines.push(title);
  }
  const [breaking, changes] = partition(commits, (c) => c.isBreaking);
  const group = groupBy(changes, "type");
  lines.push(...formatSection(breaking, options.titles.breakingChanges, options));
  for (const type of Object.keys(options.types)) {
    const items = group[type] || [];
    lines.push(...formatSection(items, options.types[type], options));
  }
  if (!lines.length) {
    lines.push("*No significant changes*");
  }
  if (!showTitle) {
    lines.push("", `##### &nbsp;&nbsp;&nbsp;&nbsp;[View changes on GitHub](${url})`);
  }
  if (showTitle) {
    lines.push("", "### &nbsp;&nbsp;&nbsp;\u2764\uFE0F Contributors", "");
    const contributorLine = createContributorLine(contributors);
    lines.push(contributorLine);
  }
  const md = convert(lines.join("\n").trim(), true);
  return md;
}
async function isVersionInMarkdown(newVersion, mdPath) {
  let isIn = false;
  let md = "";
  try {
    md = await readFile2(mdPath, "utf8");
  } catch (error) {
  }
  if (md) {
    const matches = md.match(VERSION_REG_OF_MARKDOWN);
    if (matches == null ? void 0 : matches.length) {
      const versionInMarkdown = `## [${newVersion}]`;
      isIn = matches.includes(versionInMarkdown);
    }
  }
  return isIn;
}
async function writeMarkdown(md, mdPath, regenerate = false) {
  let changelogMD = "";
  const changelogPrefix = "# Changelog";
  if (!existsSync(mdPath)) {
    await writeFile(mdPath, `${changelogPrefix}

`, "utf8");
  }
  if (!regenerate) {
    changelogMD = await readFile2(mdPath, "utf8");
  }
  if (!changelogMD.startsWith(changelogPrefix)) {
    changelogMD = `${changelogPrefix}

${changelogMD}`;
  }
  const lastEntry = changelogMD.match(/^###?\s+.*$/m);
  if (lastEntry) {
    changelogMD = `${changelogMD.slice(0, lastEntry.index) + md}

${changelogMD.slice(lastEntry.index)}`;
  } else {
    changelogMD += `
${md}

`;
  }
  await writeFile(mdPath, changelogMD);
}

// src/index.ts
async function getChangelogMarkdown(options, showTitle = true) {
  const opts = await createOptions(options);
  const current = await getCurrentGitBranch();
  const to = opts.tags.includes(opts.to) ? opts.to : current;
  const gitCommits = await getGitCommits(opts.from, to);
  const resolvedLogins = /* @__PURE__ */ new Map();
  const { commits, contributors } = await getGitCommitsAndResolvedAuthors(gitCommits, opts.github, resolvedLogins);
  const markdown = generateMarkdown({ commits, options: opts, showTitle, contributors });
  return {
    markdown,
    commits,
    options: opts
  };
}
async function getTotalChangelogMarkdown(options, showProgress = true) {
  const opts = await createOptions(options);
  let bar = null;
  if (showProgress) {
    bar = new SingleBar(
      { format: "generate total changelog: [{bar}] {percentage}% | ETA: {eta}s | {value}/{total}" },
      Presets.shades_classic
    );
  }
  const tags = getFromToTags(opts.tags);
  if (tags.length === 0) {
    const { markdown: markdown2 } = await getChangelogMarkdown(opts);
    return markdown2;
  }
  bar == null ? void 0 : bar.start(tags.length, 0);
  let markdown = "";
  const resolvedLogins = /* @__PURE__ */ new Map();
  for await (const [index, tag] of tags.entries()) {
    const { from, to } = tag;
    const gitCommits = await getGitCommits(from, to);
    const { commits, contributors } = await getGitCommitsAndResolvedAuthors(gitCommits, opts.github, resolvedLogins);
    const nextMd = generateMarkdown({ commits, options: { ...opts, from, to }, showTitle: true, contributors });
    markdown = `${nextMd}

${markdown}`;
    bar == null ? void 0 : bar.update(index + 1);
  }
  bar == null ? void 0 : bar.stop();
  return markdown;
}
async function generateChangelog(options) {
  const opts = await createOptions(options);
  const existContent = await isVersionInMarkdown(opts.to, opts.output);
  if (!opts.regenerate && existContent)
    return;
  const { markdown } = await getChangelogMarkdown(opts);
  await writeMarkdown(markdown, opts.output, opts.regenerate);
}
async function generateTotalChangelog(options, showProgress = true) {
  const opts = await createOptions(options);
  const markdown = await getTotalChangelogMarkdown(opts, showProgress);
  await writeMarkdown(markdown, opts.output, true);
}
export {
  generateChangelog,
  generateTotalChangelog,
  getChangelogMarkdown,
  getTotalChangelogMarkdown
};
