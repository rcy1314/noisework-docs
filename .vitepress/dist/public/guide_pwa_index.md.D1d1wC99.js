import{_ as n,c as s,o as a,a2 as p}from"./chunks/framework.DQS5QPof.js";const v=JSON.parse('{"title":"PWA模式","description":"","frontmatter":{},"headers":[],"relativePath":"guide/pwa/index.md","filePath":"guide/pwa/index.md"}'),e={name:"guide/pwa/index.md"},l=p(`<h1 id="pwa模式" tabindex="-1">PWA模式 <a class="header-anchor" href="#pwa模式" aria-label="Permalink to &quot;PWA模式&quot;">​</a></h1><h3 id="什么是pwa" tabindex="-1">什么是pwa <a class="header-anchor" href="#什么是pwa" aria-label="Permalink to &quot;什么是pwa&quot;">​</a></h3><p>PWA，全称为“Progressive Web App”，即“渐进式网页应用”，是一种新型的应用模式，旨在将网页应用和原生应用的优势结合起来。PWA的核心理念是让用户通过网页访问应用，同时又能享受到接近原生应用的体验。以下是PWA的一些关键特点：</p><ol><li><strong>无需安装</strong>：用户不需要从应用商店下载安装，只需通过浏览器访问即可使用。</li><li><strong>离线访问</strong>：通过服务工作线程（Service Workers）技术，PWA应用可以在没有网络连接的情况下继续工作。</li><li><strong>快速加载</strong>：PWA应用会缓存资源，使得应用加载速度更快。</li><li><strong>安全性</strong>：通过HTTPS协议传输数据，确保数据传输的安全性。</li><li><strong>可发现性</strong>：可以通过Web App Manifest文件告诉浏览器这是一个应用，浏览器会将其显示在应用列表中。</li><li><strong>可链接性</strong>：应用可以通过URL直接访问，易于分享。</li><li><strong>可重用性</strong>：代码可以在不同的设备和平台上重用，不需要为每个平台单独开发。</li><li><strong>响应式设计</strong>：应用界面会根据设备屏幕尺寸自动调整，适应各种设备。</li></ol><p>PWA的这些特性使得它在开发成本、维护成本、用户获取成本等方面都具有优势，并且能够提供更好的用户体验。</p><h2 id="引入" tabindex="-1">引入 <a class="header-anchor" href="#引入" aria-label="Permalink to &quot;引入&quot;">​</a></h2><p>html部分：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;!-- 添加Service Worker --&gt;</span></span>
<span class="line"><span>    &lt;script&gt;</span></span>
<span class="line"><span>        if (&#39;serviceWorker&#39; in navigator) {</span></span>
<span class="line"><span>            window.addEventListener(&#39;load&#39;, function() {</span></span>
<span class="line"><span>                navigator.serviceWorker.register(&#39;/service-worker.js&#39;).then(function(registration) {</span></span>
<span class="line"><span>                    console.log(&#39;ServiceWorker registration successful with scope: &#39;, registration.scope);</span></span>
<span class="line"><span>                }).catch(function(error) {</span></span>
<span class="line"><span>                    console.log(&#39;ServiceWorker registration failed: &#39;, error);</span></span>
<span class="line"><span>                });</span></span>
<span class="line"><span>            });</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    &lt;/script&gt;</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> &lt;link rel=&quot;manifest&quot; href=&quot;manifest.json&quot;&gt;</span></span></code></pre></div><p>重要的是service-worker.js和manifest.json，其中service-worker.js为工作缓存文件，manifest.json为记录页面配置信息</p><p>service-worker.js示例代码</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>var cacheName = &#39;Noise主页-v1.3.4&#39;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>self.addEventListener(&#39;install&#39;, function(event) {</span></span>
<span class="line"><span>  event.waitUntil(</span></span>
<span class="line"><span>    caches.open(cacheName).then(function(cache) {</span></span>
<span class="line"><span>      return cache.addAll([</span></span>
<span class="line"><span>        &#39;/&#39;,</span></span>
<span class="line"><span>        &#39;/assets/&#39;,</span></span>
<span class="line"><span>        &#39;/css/main.css&#39;,</span></span>
<span class="line"><span>        &#39;/js/main.js&#39;,</span></span>
<span class="line"><span>        // 添加您需要缓存的其他静态资源</span></span>
<span class="line"><span>      ]);</span></span>
<span class="line"><span>    })</span></span>
<span class="line"><span>  );</span></span>
<span class="line"><span>});</span></span>
<span class="line"><span></span></span>
<span class="line"><span>self.addEventListener(&#39;fetch&#39;, function(event) {</span></span>
<span class="line"><span>  event.respondWith(</span></span>
<span class="line"><span>    caches.match(event.request).then(function(response) {</span></span>
<span class="line"><span>      if (response) {</span></span>
<span class="line"><span>        return response;</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      // 如果请求未在缓存中找到，则发起网络请求</span></span>
<span class="line"><span>      return fetch(event.request).then(function(networkResponse) {</span></span>
<span class="line"><span>        // 将请求的响应添加到缓存中</span></span>
<span class="line"><span>        caches.open(cacheName).then(function(cache) {</span></span>
<span class="line"><span>          cache.put(event.request, networkResponse.clone());</span></span>
<span class="line"><span>        });</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        return networkResponse;</span></span>
<span class="line"><span>      });</span></span>
<span class="line"><span>    })</span></span>
<span class="line"><span>  );</span></span>
<span class="line"><span>});</span></span>
<span class="line"><span></span></span>
<span class="line"><span>self.addEventListener(&#39;activate&#39;, function(event) {</span></span>
<span class="line"><span>  event.waitUntil(</span></span>
<span class="line"><span>    caches.keys().then(function(cacheNames) {</span></span>
<span class="line"><span>      return Promise.all(</span></span>
<span class="line"><span>        cacheNames.filter(function(name) {</span></span>
<span class="line"><span>          // 删除旧版本的缓存</span></span>
<span class="line"><span>          return name !== cacheName;</span></span>
<span class="line"><span>        }).map(function(name) {</span></span>
<span class="line"><span>          return caches.delete(name);</span></span>
<span class="line"><span>        })</span></span>
<span class="line"><span>      );</span></span>
<span class="line"><span>    })</span></span>
<span class="line"><span>  );</span></span>
<span class="line"><span>});</span></span></code></pre></div><p>在本次配置中我简单的设置了一点缓存文件，不推荐设置过多，因为你每次更新后只要存在缓存会不能即时查看更新后的页面，当然，可通过更改版本号来强制要求浏览器完成刷新</p>`,13),i=[l];function t(c,r,o,d,h,u){return a(),s("div",null,i)}const f=n(e,[["render",t]]);export{v as __pageData,f as default};
